{\rtf1\ansi\ansicpg1252\cocoartf1343\cocoasubrtf160
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red191\green191\blue191;\red0\green116\blue0;\red170\green13\blue145;
\red28\green0\blue207;\red196\green26\blue22;}
\paperw11900\paperh16840\margl1440\margr1440\vieww12200\viewh15260\viewkind1
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 \
\
					
\b SENTIMENT ANALYSIS REPORT\
						   (7th February 2015)
\b0 \
\
First of all, I have worked on 
\b SentiWordNet v3.0.0
\b0 , whenever I encounter '#', I ignore those lines. Then, I split the lines on token '#', I ignore the ID and I took only the pos/term as a key and corresponding this key I store a pair of \{Pos score, Neg score\}. Thus a dictionary named sent_word_net is formed.\
\
I have worked on 
\b Amazon Product Review Dataset
\b0  although my project is Group1. Out of so many reviews I have worked on 1657 reviews.\
\
I have used NLP(Natural language Processing) tool i.e. NLTK(for python) and used this on the amazon dataset. NLTK tool will give the pair of word and corresponding tag \{'word', 'tag'\}. With the help of that tag, the Key will be formed i.e. pos/ word.\
\

\b Methodology:
\b0 \
From dictionary sent_word_net, I collect all the positive and negative scores corresponding keys for each review. Thus, Total Positive and Total Negative score for a line/review I get. Following this, I calculated the mean positive and mean negative scores and Objectivity score (1 - Pos score - Neg score) as well. The review is termed as positive(1) if the mean positive is greater equal to that mean negative otherwise it is termed as Negative(0). The score assigned as positive(1) and negative(0) is termed as 
\i\b Predicted Score
\i0\b0 . The extracted review Id of each line and the corresponding predicted score is then added in a dictionary to maintain the various reviews and their score to be fetched at later point.\
\
I did manual evaluation of  100 reviews which I stored in a Text file named ManualReview.txt containing 
\i review ID
\i0  and the 
\i manual score
\i0 (for 
\i\b positive: 1
\i0\b0  and for 
\i\b negative: 0
\i0\b0 ). This Manual review text file is read and each review is checked and its corresponding predicted score is retrieved from the dictionary.\
\
The 
\i\b manual(Actual) score
\i0\b0  is matched with predicted score. Four cases formed:\
\
1: 
\i\b True Positive:
\i0\b0  If predicted is equal to manual and predicted equals to positive, then the review is termed as true positive.\
2: 
\i\b True Negative: 
\i0\b0 If predicted is equal to manual and predicted equals to Negative, then the review is termed as true Negative.\
3: 
\i\b False Positive: 
\i0\b0 If predicted is not equal to manual and predicted equals to positive, then the review is termed as false positive.\
4: 
\i\b False Negative:
\i0\b0  If predicted is  not equal to manual and predicted equals to Negative, then the review is termed as false Negative.\
\
Total TP, TN, FP, FN reviews are calculated and displayed. Also, the false positive and false negative review id\'92s were collected and later reviewed.\
\
\
\
\
Values of confidence matrix obtained are :\

\b \
CONFIDENCE MATRIX
\b0 \
\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1520\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2480\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2440\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \cell 
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0  Predicted +\cell 
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0  Predicted -\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1520\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2480\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2440\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 Actual +\cell 
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 63\cell 
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 3\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1520\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2480\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2440\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 Actual -\cell 
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 29\cell 
\pard\intbl\itap1\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 5\cell \lastrow\row
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
TP: 63\
TN: 5\
FP: 29\
FN: 3\
\
Total True predicted: 68% ~ 70%\
and  False Predicted: ~30%\
\
Therefore, \
Accuracy Probability: ~0.7 \
Error Probability: ~0.3\
\
Based on the review id\'92s of FP and FN, I manually evaluated those Id\'92s to find the reason for misclassification of those review ID\'92s. The negative and positive score of FP and FN varies a little bit with less difference of around ~0.05 between them while those of True positive and True Negative the difference between their positive and negative values varies with greater difference. But some TP and TN's difference was like FP and FN which require comparing and checking each word of line which are present in sentiWordNet dictionary for 50/100 reviews. \
\
\
\
*************************************************************************************************************************\
CODE\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\qc
\cf0 \
\pard\tx529\pardeftab529\pardirnatural

\f1\fs22 \cf3 \CocoaLigature0 #! /usr/bin/env python\cf0 \
\
\cf4 import\cf0  numpy \cf4 as\cf0  np\
\cf4 import\cf0  nltk;\
\cf4 import\cf0  pprint;\
\cf4 import\cf0  csv\
\cf4 import\cf0  collections\
\cf4 import\cf0  textwrap\
\
\cf4 from\cf0  nltk.corpus \cf4 import\cf0  wordnet \cf4 as\cf0  wn\
\cf4 from\cf0  nltk.tokenize \cf4 import\cf0  word_tokenize\
\
inputLines = []\
filePath = \cf5 'sentiword.txt'\cf0 \
wordnet = []\
falseNeg = []\
falsePos = []\
truePos = []\
trueNeg = []\
\cf4 global\cf0  reviewDict\
reviewDict = \{\}\
\
\cf3 #define two lists: one for positive score and other for negative score\cf0 \
posList = []\
negList = []\
\
\cf3 #variable for confidence matrix\cf0 \
\cf4 global\cf0  falsePositive\
\cf4 global\cf0  falseNegative\
\cf4 global\cf0  trueNegative\
\cf4 global\cf0  truePositive\
\
\cf3 #loading senti word net dictionary\cf0 \
\cf4 def\cf0  sentiWordNet():\
    \
    sent_scores = collections.defaultdict(list)\
    \
    f = open(filePath)\
    reader = csv.reader(f, delimiter=\cf5 '\\t'\cf0 )\
    \cf4 for\cf0  line \cf4 in\cf0  reader:\
        \cf4 if\cf0  line[\cf5 0\cf0 ].startswith(\cf6 "#"\cf0 ):\
            \cf4 continue\cf0 \
        \cf4 if\cf0  len(line) == \cf5 1\cf0 :\
            \cf4 continue\cf0 \
            \
        POS, ID, PosScore, NegScore, SynsetTerms, Gloss = line\
        \
        \cf4 if\cf0  len(POS) == \cf5 0\cf0  \cf4 or\cf0  len(ID) == \cf5 0\cf0 :\
            \cf4 continue\cf0 \
        \cf3 # print POS,PosScore,NegScore,SynsetTerms\cf0 \
        \cf4 for\cf0  term \cf4 in\cf0  SynsetTerms.split(\cf6 " "\cf0 ):\
            \cf3 # drop #number at the end of every term\cf0 \
            term = term.split(\cf6 "#"\cf0 )[\cf5 0\cf0 ]\
            term = term.replace(\cf6 "-"\cf0 , \cf6 " "\cf0 ).replace(\cf6 "_"\cf0 , \cf6 " "\cf0 )\
            key = \cf6 "%s/%s"\cf0  % (POS, term.split(\cf6 "#"\cf0 )[\cf5 0\cf0 ])\
            sent_scores[key].append((float(PosScore), float(NegScore)))\
        \
    \cf4 for\cf0  key, value \cf4 in\cf0  sent_scores.items():\
        sent_scores[key] = np.mean(value, axis=\cf5 0\cf0 )\
        \
    \cf4 return\cf0  sent_scores\
\
sentiLib = sentiWordNet()\
\
\cf3 #to determine whether the word is stopword in english dictionary or not\cf0 \
\cf4 def\cf0  is_stopWord(word):\
    \cf4 if\cf0  word.lower() \cf4 in\cf0  nltk.corpus.stopwords.words(\cf5 'english'\cf0 ):\
        \cf4 return\cf0  True\
    \cf4 return\cf0  False\
\
\cf3 #Read sentiwordNet and calculate scores\cf0 \
\cf4 def\cf0  sentiment(line):\
\
    tokens = word_tokenize(line)\
    tag_tuples = nltk.pos_tag(tokens)\
    tag_type = \cf5 0\cf0 \
\
    \cf4 for\cf0  (string, tag) \cf4 in\cf0  tag_tuples:\
\
        \cf4 if\cf0  tag.startswith(\cf6 "JJ"\cf0 ):\
            tag_type = \cf6 "a"\cf0 \
        \cf4 if\cf0  tag.startswith(\cf6 "NN"\cf0 ):\
            tag_type = \cf6 "n"\cf0 \
        \cf4 if\cf0  tag.startswith(\cf6 "RB"\cf0 ):\
            tag_type = \cf6 "r"\cf0 \
        \cf4 if\cf0  tag.startswith(\cf6 "VB"\cf0 ):\
            tag_type = \cf6 "v"\cf0 \
\
        \cf3 #remove stop words\cf0 \
        \cf4 if\cf0  is_stopWord(string):\
            \cf4 continue\cf0 \
\
        \cf3 #remove punctuations\cf0 \
        \cf4 if\cf0  \cf4 not\cf0  is_punctuation(string):\
            token = \{\cf5 'word'\cf0 :string, \cf5 'pos'\cf0 :tag_type\}\
            sentence = \cf6 "%s/%s"\cf0 %(tag_type, string)\
\
            \cf4 if\cf0  sentence \cf4 in\cf0  sentiLib:\
                pos, neg = sentiLib[sentence]\
                posList.append(pos)\
                negList.append(neg)\
\
\cf3 #check whether parametric value is punctuation or not\cf0 \
\cf4 def\cf0  is_punctuation(string):\
    \cf4 for\cf0  char \cf4 in\cf0  string:\
        \cf4 if\cf0  char.isalpha() \cf4 or\cf0  char.isdigit():\
            \cf4 return\cf0  False\
    \cf4 return\cf0  True\
\
\cf3 #Function to read input file\cf0 \
\cf4 def\cf0  readFileContent():\
    \cf4 print\cf0  \cf5 'Inside readFileContent Method'\cf0 \
    \
    LinePos = \cf5 0\cf0 \
    lineNeg = \cf5 0\cf0 \
    lineCount = \cf5 0\cf0 \
    objScore = \cf5 0\cf0 \
    ch = \cf5 0\cf0 \
    \
    \cf4 print\cf0  \cf5 'PREDICTED SCORE:'\cf0 \
    \cf4 print\cf0  \cf5 'LineNum\\t\\tReview Id\\t\\tTitle\\t\\t\\tPositive Score\\t\\tNegative Score\\t\\tObj Score\\t\\t\\tResult'\cf0 \
    \
    \cf4 with\cf0  open(\cf5 'randomfile2.txt'\cf0 ) \cf4 as\cf0  inputfile:\
        \cf4 for\cf0  line \cf4 in\cf0  inputfile:\
            \cf4 if\cf0  (ch > \cf5 0\cf0  \cf4 and\cf0  ch <= \cf5 300\cf0 ):\
                lineCount = lineCount + \cf5 1\cf0 \
            \
                fileDesc = line.split(\cf5 '\\t'\cf0 )\
            \
                inputLines.append(line)\
                sentiment(line)\
\
                \cf3 #calculate total positive score for a line\cf0 \
                LinePos = calculateMean(posList)\
                lineNeg = calculateMean(negList)\
                objScore = \cf5 1\cf0  - LinePos - lineNeg\
            \
                predScore = PosNeg(LinePos, lineNeg)\
                \cf3 #dictProgramReview(fileDesc[0], predScore)\cf0 \
                reviewDict[str(fileDesc[\cf5 0\cf0 ])] = str(predScore)\
\
                \cf4 del\cf0  posList[:]\
                \cf4 del\cf0  negList[:]\
                \
                \cf4 print\cf0  str(lineCount) + \cf5 '\\t\\t'\cf0  + str(fileDesc[\cf5 0\cf0 ]) + \cf5 '\\t\\t'\cf0  + str(fileDesc[\cf5 1\cf0 ]) + \cf5 '\\t\\t'\cf0  + str(LinePos) + \cf5 '\\t\\t'\cf0  + str(lineNeg) + \cf5 '\\t\\t'\cf0  + str(objScore)  + \cf5 '\\t\\t'\cf0  + str(PosNeg(LinePos, lineNeg))\
                \
                ch = ch + \cf5 1\cf0 \
            \cf4 else\cf0 :\
                ch = ch + \cf5 1\cf0 \
    \
    \cf4 print\cf0  \cf5 'going inside readManualFile'\cf0 \
    tp, tn, fp, fn = readManualFile()\
    \cf4 print\cf0  \cf5 'True positive: '\cf0  , str(tp), \cf5 '\\n'\cf0 , \cf5 'True Negative'\cf0 , str(tn)\
    \cf4 print\cf0  \cf5 'False positive: '\cf0 , str(fp), \cf5 '\\n'\cf0 , \cf5 'False Negative'\cf0 , str(fn)\
\
\cf3 #function to calculate more Positive or more negative\cf0 \
\cf4 def\cf0  PosNeg(posNum, negNum):\
    \cf4 if\cf0  posNum >= negNum:\
        \cf4 return\cf0  \cf5 1\cf0 \
\
    \cf4 else\cf0 :\
        \cf4 return\cf0  \cf5 0\cf0 \
\
\cf3 #function to calculate mean of a list\cf0 \
\cf4 def\cf0  calculateMean(list):\
    \cf4 return\cf0 (reduce(\cf4 lambda\cf0  x, y: x + y, list) / len(list))\
\
\cf3 #Manually read a file to get the review\cf0 \
\cf4 def\cf0  readManualFile():\
    \
    falsePositive = \cf5 0\cf0 \
    falseNegative = \cf5 0\cf0 \
    trueNegative = \cf5 0\cf0 \
    truePositive = \cf5 0\cf0 \
    \
    f = open(\cf5 'ManualReview.txt'\cf0 )\
    \
    \cf4 for\cf0  line \cf4 in\cf0  range(\cf5 100\cf0 ):\
        id,scoreMan = f.readline().rsplit(\cf4 None\cf0 , \cf5 1\cf0 )\
        scorePred = reviewDict[str(id)]\
        \
        \cf3 #Calculate confidence matrix values\cf0 \
        \cf4 print\cf0  \cf5 'score pred: '\cf0 ,str(scorePred), \cf5 'scoreman: '\cf0 , str(scoreMan)\
        \cf4 if\cf0  str(scorePred) == str(\cf5 0\cf0 ):\
            \cf4 if\cf0  str(scorePred) == str(scoreMan):\
                \cf4 print\cf0  \cf5 'true negative'\cf0 , str(trueNegative), \cf5 'predicted score: '\cf0  , str(scorePred), \cf5 'Manual score: '\cf0  , str(scoreMan)\
                trueNegative = trueNegative + \cf5 1\cf0 \
                trueNeg.append(id)\
            \cf4 else\cf0 :\
                \cf4 print\cf0  \cf5 'false negative'\cf0 , str(falseNegative), \cf5 'predicted score: '\cf0  , str(scorePred), \cf5 'Manual score: '\cf0  , str(scoreMan)\
                falseNegative = falseNegative + \cf5 1\cf0 \
                falseNeg.append(id)\
        \cf4 if\cf0  str(scorePred) == str(\cf5 1\cf0 ):\
            \cf4 if\cf0  str(scorePred) == str(scoreMan):\
                \cf4 print\cf0  \cf5 'true positive'\cf0 , str(truePositive), \cf5 'predicted score: '\cf0  , str(scorePred), \cf5 'Manual score: '\cf0  , str(scoreMan)\
                truePositive = truePositive + \cf5 1\cf0 \
                truePos.append(id)\
            \cf4 else\cf0 :\
                \cf4 print\cf0  \cf5 'false positive'\cf0 , str(falsePositive), \cf5 'predicted score: '\cf0  , str(scorePred), \cf5 'Manual score: '\cf0  , str(scoreMan)\
                falsePositive = falsePositive + \cf5 1\cf0 \
                falsePos.append(str(id))\
                falsePos.append(id)\
\
    \cf4 return\cf0  truePositive, trueNegative, falsePositive, falseNegative\
\
\cf3 #function to store predicted values in dictionary\cf0 \
\cf3 #def dictProgramReview(id, score):\cf0 \
\cf3 #reviewDict.update(\{str(id) : str(score)\})\cf0 \
\
\cf3 #Main function\cf0 \
\cf4 def\cf0  main():\
\
    readFileContent()\
    \cf4 print\cf0  \cf5 '***********after readFileContent********'\cf0 \
\
    \cf4 print\cf0  \cf5 '**********************************FALSE POSITIVE**********************'\cf0 \
    \cf4 for\cf0  fp \cf4 in\cf0  falsePos:\
        \cf4 print\cf0  \cf5 'fp: '\cf0 , fp\
    \
    \cf4 print\cf0  \cf5 '**********************************FALSE NEGATIVE**********************'\cf0 \
    \cf4 for\cf0  fn \cf4 in\cf0  falseNeg:\
        \cf4 print\cf0  \cf5 'fn: '\cf0  , fn\
\
    \cf4 print\cf0  \cf5 '**********************************TRUE POSITIVE**********************'\cf0 \
    \cf4 for\cf0  tp \cf4 in\cf0  truePos:\
        \cf4 print\cf0  \cf5 'tp: '\cf0 , tp\
\
    \cf4 print\cf0  \cf5 '**********************************TRUE NEGATIVE**********************'\cf0 \
    \cf4 for\cf0  tn \cf4 in\cf0  trueNeg:\
        \cf4 print\cf0  \cf5 'tn: '\cf0 , tn\
\
main()
\f0\fs24 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\qc
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
\
\
}